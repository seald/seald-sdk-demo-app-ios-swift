//
//  ContentView.swift
//  seald-sdk-demo-app-ios-swift
//
//  Created by Mehdi Kouhen on 28/02/2023.
//  Copyright Â© 2023 Seald SAS. All rights reserved.
//
// swiftlint:disable force_cast

import SwiftUI
import SealdSdk

struct TestCredentials {
    var apiURL: String
    var appId: String
    var JWTSharedSecretId: String
    var JWTSharedSecret: String
    var ssksURL: String
    var ssksBackendAppKey: String
    var ssksTMRChallenge: String
}

func randomString(length: Int) -> String {
    let letters = "abcdefghijklmnopqrstuvwxyz0123456789"
    return String((0..<length).map { _ in letters.randomElement()! })
}

func randomData(length: Int) -> Data {
    return Data((0..<length).map { _ in UInt8.random(in: 0...UInt8.max) })
}

func testSealdSDK() async -> Bool {
    do {
        // The SealdSDK uses a local database. This database should be written to a permanent directory.
        // On iOS, in Swift, the recommended path is `documentDirectory`.
        let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
        let documentsDirectory = paths[0]
        let sealdDir = "\(documentsDirectory)/seald-swift"

        // The Seald SDK uses a local database that will persist on disk.
        // When instantiating a SealdSDK, it is highly recommended to set a symmetric key to encrypt this database.
        // In an actual app, it should be generated at signup,
        // either on the server and retrieved from your backend at login,
        // or on the client-side directly and stored in the system's keychain.
        // WARNING: This should be a cryptographically random buffer of 64 bytes.
        // This random generation is NOT good enough.
        let databaseEncryptionKey = randomData(length: 64)

        // This demo expects a clean database path to create it's own data, so we need to clean what previous runs left.
        // In a real app, it should never be done.
        let fileManager = FileManager.default
        try? fileManager.removeItem(atPath: sealdDir)

        // Seald uses JWT to manage licenses and identity.
        // JWTs should be generated by your backend, and sent to the user at signup.
        // The JWT secretId and secret can be generated from your administration dashboard.
        // They should NEVER be on client side.
        // However, as this is a demo without a backend, we will use them on the frontend.
        // JWT documentation: https://docs.seald.io/en/sdk/guides/jwt.html
        // identity documentation: https://docs.seald.io/en/sdk/guides/4-identities.html
        let jwtBuilder = JWTBuilder(
            JWTSharedSecretId: testCredentials.JWTSharedSecretId,
            JWTSharedSecret: testCredentials.JWTSharedSecret)

        // let's instantiate 3 SealdSDK. They will correspond to 3 users that will exchange messages.
        let sdk1 = try SealdSdk.init(
            apiUrl: testCredentials.apiURL,
            appId: testCredentials.appId,
            databasePath: "\(sealdDir)/sdk1",
            databaseEncryptionKey: databaseEncryptionKey,
            instanceName: "Swift-Instance-1",
            logLevel: -1,
            logNoColor: true,
            encryptionSessionCacheTTL: 0,
            keySize: 4096)
        let sdk2 = try SealdSdk.init(apiUrl: testCredentials.apiURL,
            appId: testCredentials.appId,
            databasePath: "\(sealdDir)/sdk2",
            databaseEncryptionKey: databaseEncryptionKey,
            instanceName: "Swift-Instance-2",
            logLevel: -1,
            logNoColor: true,
            encryptionSessionCacheTTL: 0,
            keySize: 4096)
        let sdk3 = try SealdSdk.init(
            apiUrl: testCredentials.apiURL,
            appId: testCredentials.appId,
            databasePath: "\(sealdDir)/sdk3",
            databaseEncryptionKey: databaseEncryptionKey,
            instanceName: "Swift-Instance-3",
            logLevel: -1,
            logNoColor: true,
            encryptionSessionCacheTTL: 0,
            keySize: 4096)

        // retrieve info about current user before creating a user should return null
        let retrieveNoAccount = sdk1.getCurrentAccountInfo()
        assert(retrieveNoAccount?.deviceId == nil)

        // Create the 3 accounts. Again, the signupJWT should be generated by your backend
        let user1AccountInfo = try await sdk1.createAccountAsync(
            withSignupJwt: jwtBuilder.signupJWT(),
            deviceName: "Swift-demo-device-1",
            displayName: "Swift-demo-user-1",
            privateKeys: nil,
            expireAfter: 5 * 365 * 24 * 60 * 60)
        let user2AccountInfo = try await sdk2.createAccountAsync(
            withSignupJwt: jwtBuilder.signupJWT(),
            deviceName: "Swift-demo-device-2",
            displayName: "Swift-demo-user-2",
            privateKeys: nil,
            expireAfter: 5 * 365 * 24 * 60 * 60)
        let user3AccountInfo = try await sdk3.createAccountAsync(
            withSignupJwt: jwtBuilder.signupJWT(),
            deviceName: "Swift-demo-device-3",
            displayName: "Swift-demo-user-3",
            privateKeys: nil,
            expireAfter: 5 * 365 * 24 * 60 * 60)

        // retrieve info about current user after creating a user should return account info:
        let retrieveAccountInfo = await sdk1.getCurrentAccountInfoAsync()
        assert(retrieveAccountInfo != nil)
        assert(retrieveAccountInfo?.userId == user1AccountInfo.userId)
        assert(retrieveAccountInfo?.deviceId == user1AccountInfo.deviceId)

        // Create group: https://docs.seald.io/sdk/guides/5-groups.html
        let groupName = "group-1"
        let groupMembers = [user1AccountInfo.userId]
        let groupAdmins = [user1AccountInfo.userId]
        let groupId = try await sdk1.createGroupAsync(
            withGroupName: groupName,
            members: groupMembers,
            admins: groupAdmins,
            privateKeys: nil)

        // Manage group members and admins
        // user1 add user2 as group member
        try await sdk1.addGroupMembersAsync(
            withGroupId: groupId,
            membersToAdd: [user2AccountInfo.userId],
            adminsToSet: [],
            privateKeys: nil)
        // user1 adds user3 as group member and group admin
        try await sdk1.addGroupMembersAsync(
            withGroupId: groupId,
            membersToAdd: [user3AccountInfo.userId],
            adminsToSet: [user3AccountInfo.userId],
            privateKeys: nil)
        // user3 can remove user2
        try await sdk3.removeGroupMembersAsync(
            withGroupId: groupId,
            membersToRemove: [user2AccountInfo.userId],
            privateKeys: nil)
        // user3 can remove user1 from admins
        try await sdk3.setGroupAdminsAsyncWithGroupId(
            groupId, addToAdmins: [],
            removeFromAdmins: [user1AccountInfo.userId])

        // Create encryption session: https://docs.seald.io/sdk/guides/6-encryption-sessions.html
        // user1, user2, and group as recipients
        // Default rights for the session creator (if included as recipients without RecipientRights):
        // read = true, forward = true, revoke = true
        // Default rights for any other recipient:  read = true, forward = true, revoke = false
        let recipients = [
            SealdRecipientWithRights(recipientId: user1AccountInfo.userId),
            SealdRecipientWithRights(recipientId: user2AccountInfo.userId),
            SealdRecipientWithRights(recipientId: groupId)]
        let es1SDK1 = try await sdk1.createEncryptionSessionAsync(withRecipients: recipients, useCache: false)
        assert(es1SDK1.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.created)

        // Using two-man-rule accesses

        // Add TMR accesses to the session, then, retrieve the session using it.
        // Create TMR a recipient
        let rand = randomString(length: 5)
        let userEM = "tmr-em-swift-\(rand)@test.com"
        let tmrAuthFactor = SealdTmrAuthFactor(value: userEM, type: "EM")

        // WARNING: This should be a cryptographically random buffer of 64 bytes.
        // This random generation is NOT good enough.
        let overEncryptionKey = randomData(length: 64)

        let tmrRecipient = SealdTmrRecipientWithRights(
            authFactor: tmrAuthFactor,
            overEncryptionKey: overEncryptionKey
        )

        // Add the TMR access
        let addedTMRId = try await es1SDK1.addTmrAccessAsync(tmrRecipient)
        assert(addedTMRId.count == 36)

        // Retrieve the TMR JWT
        let SSKSBackend = SSKSBackend(
            keyStorageURL: testCredentials.ssksURL,
            appId: testCredentials.appId,
            appKey: testCredentials.ssksBackendAppKey)

        // Retrieve the TMR JWT
        let ssksTMR = SealdSsksTMRPlugin(ssksURL: testCredentials.ssksURL,
        appId: testCredentials.appId, instanceName: "SdkDemoAppIosSwiftTmrAccess", logLevel: -1, logNoColor: true)

        // The app backend creates an SSKS authentication session.
        // This is the first time that this email is authenticating onto SSKS, so `mustAuthenticate` would be false,
        // but we force auth because we want to convert TMR accesses.
        let tmrSession = try await SSKSBackend.challengeSend(
            userId: user2AccountInfo.userId,
            authFactor: tmrAuthFactor,
            createUser: true,
            forceAuth: true,
            // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'.
            // In production, you cannot use this.
            fakeOtp: true
        )
        assert(tmrSession.mustAuthenticate == true)

        // Retrieve a JWT associated with the authentication factor from SSKS
        let tmrJWT = try await ssksTMR.getFactorTokenAsync(
            sessionId: tmrSession.sessionId,
            authFactor: tmrAuthFactor,
            challenge: testCredentials.ssksTMRChallenge
        )

        // Retrieve the encryption session using the JWT
        let tmrES = try await sdk2.retrieveEncryptionSessionAsync(
            byTmr: tmrJWT.token,
            sessionId: es1SDK1.sessionId,
            overEncryptionKey: overEncryptionKey,
            tmrAccessesFilters: nil,
            tryIfMultiple: true,
            useCache: false
        )
        assert(tmrES.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.viaTmrAccess)

        // Convert the TMR accesses
        try await sdk2.convertTmrAccessesAsync(
            tmrJWT.token,
            overEncryptionKey: overEncryptionKey,
            conversionFilters: nil,
            deleteOnConvert: true
        )

        // After conversion, sdk2 can retrieve the encryption session directly.
        let classicES = try await sdk2.retrieveEncryptionSessionAsync(
            withSessionId: es1SDK1.sessionId,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false
        )
        assert(classicES.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.direct)

        // Using proxy sessions: https://docs.seald.io/sdk/guides/proxy-sessions.html

        // Create proxy sessions:
        // user1 needs to be a recipient of this session in order to be able to add it as a proxy session
        let proxySession1 = try await sdk1.createEncryptionSessionAsync(
            withRecipients: [
            SealdRecipientWithRights(recipientId: user1AccountInfo.userId),
            SealdRecipientWithRights(recipientId: user3AccountInfo.userId)
        ],
            useCache: false
        )
        try await es1SDK1.addProxySessionAsync(proxySession1.sessionId)

        // user1 needs to be a recipient of this session in order to be able to add it as a proxy session
        let proxySession2 = try await sdk1.createEncryptionSessionAsync(
            withRecipients: [
            SealdRecipientWithRights(recipientId: user1AccountInfo.userId),
            SealdRecipientWithRights(recipientId: user2AccountInfo.userId)
        ],
            useCache: false
        )
        try await es1SDK1.addProxySessionAsync(proxySession2.sessionId)

        // The SealdEncryptionSession object can encrypt and decrypt for user1
        let initialString = "a message that needs to be encrypted!"
        let encryptedMessage = try await es1SDK1.encryptMessageAsync(initialString)
        let decryptedMessage = try await es1SDK1.decryptMessageAsync(encryptedMessage)
        assert(initialString == decryptedMessage)

        // user1 can parse/retrieve the EncryptionSession from the encrypted message
        let es1SDK1FromMessId = try SealdUtils.parseSessionId(fromMessage: encryptedMessage)
        assert(es1SDK1FromMessId == es1SDK1.sessionId)
        let es1SDK1RetrieveFromMess = try await sdk1.retrieveEncryptionSessionAsync(
            fromMessage: encryptedMessage,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        assert(es1SDK1RetrieveFromMess.sessionId == es1SDK1.sessionId)
        assert(es1SDK1RetrieveFromMess.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.direct)
        let decryptedMessageFromMess = try await es1SDK1RetrieveFromMess.decryptMessageAsync(encryptedMessage)
        assert(initialString == decryptedMessageFromMess)

        // Create a test file on disk that we will encrypt/decrypt
        let filename = "testfile.txt"
        let fileContent = "File clear data."
        let filePath = "\(sealdDir)/\(filename)"
        try fileContent.write(toFile: filePath, atomically: true, encoding: .utf8)

        // Encrypt the test file. Resulting file will be written alongside the source
        // file, with `.seald` extension added
        let encryptedFileURI = try await es1SDK1.encryptFileAsync(fromURI: filePath)

        // User1 can parse/retrieve the encryptionSession directly from the encrypted file
        let es1SDK1FromFileId = try SealdUtils.parseSessionId(fromFile: encryptedFileURI)
        assert(es1SDK1FromFileId == es1SDK1.sessionId)
        let es1SDK1FromFile = try await sdk1.retrieveEncryptionSessionAsync(
            fromFile: encryptedFileURI,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        assert(es1SDK1FromFile.sessionId == es1SDK1.sessionId)
        assert(es1SDK1FromFile.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.direct)

        // The retrieved session can decrypt the file.
        // The decrypted file will be named with the name it had at encryption.
        // Any renaming of the encrypted file will be ignored.
        // NOTE: In this example, the decrypted file will have `(1)` suffix to avoid overwriting
        // the original clear file.
        let decryptedFileURI = try await es1SDK1FromFile.decryptFileAsync(fromURI: encryptedFileURI)
        assert(decryptedFileURI.hasSuffix("testfile (1).txt"))
        let decryptedFileContent = try String(contentsOfFile: decryptedFileURI, encoding: .utf8)
        assert(fileContent == decryptedFileContent)

        // User1 can parse/retrieve the encryptionSession directly from the encrypted file bytes
        let fileBytes = try Data(contentsOf: URL(fileURLWithPath: encryptedFileURI))
        let es1SDK1FromBytesId = try SealdUtils.parseSessionId(fromBytes: fileBytes)
        assert(es1SDK1FromBytesId == es1SDK1.sessionId)
        let es1SDK1FromBytes = try await sdk1.retrieveEncryptionSessionAsync(
            fromBytes: fileBytes,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        assert(es1SDK1FromBytes.sessionId == es1SDK1.sessionId)
        assert(es1SDK1FromBytes.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.direct)

        // user2 can retrieve the encryptionSession from the session ID.
        let es1SDK2 = try await sdk2.retrieveEncryptionSessionAsync(
            withSessionId: es1SDK1.sessionId,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        assert(es1SDK2.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.direct)
        let decryptedMessageSDK2 = try await es1SDK2.decryptMessageAsync(encryptedMessage)
        assert(initialString == decryptedMessageSDK2)

        // user3 cannot retrieve the SealdEncryptionSession with lookupGroupKey set to false.
        do {
            _ = try await sdk3.retrieveEncryptionSessionAsync(
                fromMessage: encryptedMessage,
                useCache: false,
                lookupProxyKey: false,
                lookupGroupKey: false)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String  == "NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["id"] as! String == "GOSDK_NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["description"] as! String == "Can't decipher this session")
        }

        // user3 can retrieve the encryptionSession from the encrypted message through the group.
        let es1SDK3FromGroup = try await sdk3.retrieveEncryptionSessionAsync(
            fromMessage: encryptedMessage,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: true)
        assert(es1SDK3FromGroup.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.viaGroup)
        assert(es1SDK3FromGroup.retrievalDetails.groupId == groupId)
        let decryptedMessageSDK3 = try await es1SDK3FromGroup.decryptMessageAsync(encryptedMessage)
        assert(initialString == decryptedMessageSDK3)

        // user3 removes all members of "group-1". A group without member is deleted.
        try await sdk3.removeGroupMembersAsync(
            withGroupId: groupId,
            membersToRemove: [user1AccountInfo.userId, user3AccountInfo.userId],
            privateKeys: nil)

        // user3 could retrieve the previous encryption session only because "group-1" was set as recipient.
        // As the group was deleted, it can no longer access it.
        // user3 still has the encryption session in its cache, but we can disable it.
        do {
            _ = try await sdk3.retrieveEncryptionSessionAsync(
                fromMessage: encryptedMessage,
                useCache: false,
                lookupProxyKey: false,
                lookupGroupKey: true)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String  == "NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["id"] as! String == "GOSDK_NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["description"] as! String == "Can't decipher this session")
        }

        // user3 can still retrieve the session via proxy.
        let es1SDK3FromProxy = try await sdk3.retrieveEncryptionSessionAsync(
            fromMessage: encryptedMessage,
            useCache: false,
            lookupProxyKey: true,
            lookupGroupKey: false)
        assert(es1SDK3FromProxy.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.viaProxy)
        assert(es1SDK3FromProxy.retrievalDetails.proxySessionId == proxySession1.sessionId)

        // user2 adds user3 as recipient of the encryption session.
        let respAdd = try await es1SDK2.addRecipientsAsync(
            [SealdRecipientWithRights(
                recipientId: user3AccountInfo.userId
            )])
        assert(respAdd.count == 1)
        assert((respAdd[user3AccountInfo.deviceId]!).success)

        // user3 can now retrieve it without group or proxy.
        let es1SDK3 = try await sdk3.retrieveEncryptionSessionAsync(
            withSessionId: es1SDK1.sessionId,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        assert(es1SDK3.retrievalDetails.flow == SealdEncryptionSessionRetrievalFlow.direct)
        let decryptedMessageAfterAdd = try await es1SDK3.decryptMessageAsync(encryptedMessage)
        assert(initialString == decryptedMessageAfterAdd)

        // user1 revokes user3 and proxy1 from the encryption session.
        let respRevoke = try await es1SDK1.revokeRecipientsIdsAsync(
            [user3AccountInfo.userId],
            proxySessionsIds: [proxySession1.sessionId])
        assert(respRevoke.recipients.count == 1)
        assert((respRevoke.recipients[user3AccountInfo.userId]!).success)
        assert(respRevoke.proxySessions.count == 1)
        assert((respRevoke.proxySessions[proxySession1.sessionId]!).success)

        // user3 cannot retrieve the session anymore, even with proxy or group
        do {
            _ = try await sdk3.retrieveEncryptionSessionAsync(
                fromMessage: encryptedMessage,
                useCache: false,
                lookupProxyKey: true,
                lookupGroupKey: true)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String  == "NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["id"] as! String == "GOSDK_NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["description"] as! String == "Can't decipher this session")
        }

        // user1 revokes all other recipients from the session
        let respRevokeOther = try await es1SDK1.revokeOthersAsync()
        assert(respRevokeOther.recipients.count == 2) // revoke user2 and group
        assert((respRevokeOther.recipients[groupId]!).success)
        assert((respRevokeOther.recipients[user2AccountInfo.userId]!).success)
        assert(respRevokeOther.proxySessions.count == 1)
        assert((respRevokeOther.proxySessions[proxySession2.sessionId]!).success)

        // user2 cannot retrieve the session anymore
        do {
            _ = try await sdk2.retrieveEncryptionSessionAsync(
                fromMessage: encryptedMessage,
                useCache: false,
                lookupProxyKey: false,
                lookupGroupKey: false)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String  == "NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["id"] as! String == "GOSDK_NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["description"] as! String == "Can't decipher this session")
        }

        // user1 revokes all. It can no longer retrieve it.
        let respRevokeAll = try await es1SDK1.revokeAllAsync()
        assert(respRevokeAll.recipients.count == 1)
        assert(respRevokeAll.recipients[user1AccountInfo.userId]!.success)
        assert(respRevokeAll.proxySessions.count == 0)

        // user1 cannot retrieve anymore
        do {
            _ = try await sdk1.retrieveEncryptionSessionAsync(
                fromMessage: encryptedMessage,
                useCache: false,
                lookupProxyKey: false,
                lookupGroupKey: false)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String  == "NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["id"] as! String == "GOSDK_NO_TOKEN_FOR_YOU")
            assert((error as NSError).userInfo["description"] as! String == "Can't decipher this session")
        }

        // Create additional data for user1
        let es2SDK1 = try await sdk1.createEncryptionSessionAsync(
            withRecipients: [SealdRecipientWithRights(
                recipientId: user1AccountInfo.userId
            )],
            useCache: false)
        let anotherMessage = "nobody should read that!"
        let secondEncryptedMessage = try await es2SDK1.encryptMessageAsync(anotherMessage)
        let es3SDK1 = try await sdk1.createEncryptionSessionAsync(
            withRecipients: [SealdRecipientWithRights(
                recipientId: user1AccountInfo.userId
            )],
            useCache: false)
        let es4SDK1 = try await sdk1.createEncryptionSessionAsync(
            withRecipients: [SealdRecipientWithRights(
                recipientId: user1AccountInfo.userId
            )],
            useCache: false)

        // user1 can retrieveMultiple
        let encryptionSessions = try await sdk1.retrieveMultipleEncryptionSessionsAsync(
            [es2SDK1.sessionId, es3SDK1.sessionId, es4SDK1.sessionId],
            useCache: false, lookupProxyKey: false, lookupGroupKey: false)
        assert(encryptionSessions.count == 3)
        assert(encryptionSessions[0].sessionId == es2SDK1.sessionId)
        assert(encryptionSessions[1].sessionId == es3SDK1.sessionId)
        assert(encryptionSessions[2].sessionId == es4SDK1.sessionId)

        // user1 can renew its key, and still decrypt old messages
        let preparedRenewal = try await sdk1.prepareRenewAsync(withPrivateKeys: nil)
        // `preparedRenewal` Can be stored on SSKS as a new identity.
        // That way, a backup will be available is the renewKeys fail.

        try await sdk1.renewKeysAsync(withPreparedRenewal: preparedRenewal,
                                      privateKeys: nil,
                                      expireAfter: TimeInterval( 5 * 365 * 24 * 60 * 60))
        let es2SDK1AfterRenew = try await sdk1.retrieveEncryptionSessionAsync(
            withSessionId: es2SDK1.sessionId,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        let decryptedMessageAfterRenew = try await es2SDK1AfterRenew.decryptMessageAsync(secondEncryptedMessage)
        assert(anotherMessage == decryptedMessageAfterRenew)

        // CONNECTORS https://docs.seald.io/en/sdk/guides/jwt.html#adding-a-userid

        // we can add a custom userId using a JWT
        let customConnectorJWTValue = "user1-custom-id"
        let addConnectorJWT = try await jwtBuilder.connectorJWT(customUserId: customConnectorJWTValue,
        appId: testCredentials.appId)
        try await sdk1.pushJWTAsync(withJWT: addConnectorJWT)

        // we can list a user connectors
        let connectors = try await sdk1.listConnectorsAsync()
        assert(connectors.count == 1)
        assert(connectors[0].state == "VO")
        assert(connectors[0].type == "AP")
        assert(connectors[0].sealdId == user1AccountInfo.userId)
        assert(connectors[0].value == "\(customConnectorJWTValue)@\(testCredentials.appId)")

        // Retrieve connector by its id
        let retrieveConnector = try await sdk1.retrieveConnectorAsync(withConnectorId: connectors[0].connectorId)
        assert(retrieveConnector.sealdId == user1AccountInfo.userId)
        assert(retrieveConnector.state == "VO")
        assert(retrieveConnector.type == "AP")
        assert(retrieveConnector.value == "\(customConnectorJWTValue)@\(testCredentials.appId)")

        // Retrieve connectors from a user id.
        let connectorsFromSealdId = try await sdk1.getConnectorsAsyncFromSealdId(sealdId: user1AccountInfo.userId)
        assert(connectorsFromSealdId.count == 1)
        assert(connectorsFromSealdId[0].state == "VO")
        assert(connectorsFromSealdId[0].type == "AP")
        assert(connectorsFromSealdId[0].sealdId == user1AccountInfo.userId)
        assert(connectorsFromSealdId[0].value == "\(customConnectorJWTValue)@\(testCredentials.appId)")

        // Get sealdId of a user from a connector
        let sealdIds = try await sdk2.getSealdIdsAsyncFromConnectors(
            connectorTypeValues: [SealdConnectorTypeValue(
                type: "AP",
                value: "\(customConnectorJWTValue)@\(testCredentials.appId)"
            )])
        assert(sealdIds.count == 1)
        assert(sealdIds[0] == user1AccountInfo.userId)

        // user1 can remove a connector
        try await sdk1.removeConnectorAsync(withConnectorId: connectors[0].connectorId)

        // verify that no connector left
        let connectorListAfterRevoke = try await sdk1.listConnectorsAsync()
        assert(connectorListAfterRevoke.count == 0)

        // user1 can export its identity
        let exportIdentity = try await sdk1.exportIdentityAsync()

        // We can instantiate a new SealdSDK, import the exported identity
        let sdk1Exported = try SealdSdk(
            apiUrl: testCredentials.apiURL,
            appId: testCredentials.appId,
            databasePath: "\(sealdDir)/sdk1Exported",
            databaseEncryptionKey: databaseEncryptionKey,
            instanceName: "sdk1Exported",
            logLevel: -1,
            logNoColor: true,
            encryptionSessionCacheTTL: TimeInterval( 5 * 365 * 24 * 60 * 60),
            keySize: 4096)
        try await sdk1Exported.importIdentityAsync(withIdentity: exportIdentity)

        // SDK with imported identity can decrypt
        let es2SDK1Exported = try await sdk1Exported.retrieveEncryptionSessionAsync(
            fromMessage: secondEncryptedMessage,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        let clearMessageExportedIdentity = try await es2SDK1Exported.decryptMessageAsync(secondEncryptedMessage)
        assert(anotherMessage == clearMessageExportedIdentity)

        // user1 can create sub identity
        let subIdentity = try await sdk1.createSubIdentityAsync(
            withDeviceName: "SUB-deviceName",
            privateKeys: nil,
            expireAfter: TimeInterval( 5 * 365 * 24 * 60 * 60))
        assert(subIdentity.deviceId != "")

        // first device needs to reencrypt for the new device
        try await sdk1.massReencryptAsync(withDeviceId: subIdentity.deviceId, options: SealdMassReencryptOptions())
        // We can instantiate a new SealdSDK, import the sub-device identity
        let sdk1SubDevice = try SealdSdk(
            apiUrl: testCredentials.apiURL,
            appId: testCredentials.appId,
            databasePath: "\(sealdDir)/sdk1SubDevice",
            databaseEncryptionKey: databaseEncryptionKey,
            instanceName: "sdk1SubDevice",
            logLevel: -1,
            logNoColor: true,
            encryptionSessionCacheTTL: TimeInterval( 5 * 365 * 24 * 60 * 60),
            keySize: 4096)
        try await sdk1SubDevice.importIdentityAsync(withIdentity: subIdentity.backupKey)

        // sub device can decrypt
        let es2SDK1SubDevice = try await sdk1SubDevice.retrieveEncryptionSessionAsync(
            fromMessage: secondEncryptedMessage,
            useCache: false,
            lookupProxyKey: false,
            lookupGroupKey: false)
        let clearMessageSubdIdentity = try await es2SDK1SubDevice.decryptMessageAsync(secondEncryptedMessage)
        assert(anotherMessage == clearMessageSubdIdentity)

        // Get and Check sigchain hash
        let user1LastSigchainHash = try await sdk1.getSigchainHashAsync(
            withUserId: user1AccountInfo.userId,
            position: -1)
        assert(user1LastSigchainHash.position == 2)
        let user1FirstSigchainHash = try await sdk1.getSigchainHashAsync(
            withUserId: user1AccountInfo.userId,
            position: 0)
        assert(user1FirstSigchainHash.position == 0)
        let lastHashCheck = try await sdk2.checkSigchainHashAsync(
            withUserId: user1AccountInfo.userId,
            expectedHash: user1LastSigchainHash.sigchainHash,
            position: -1)
        assert(lastHashCheck.found)
        assert(lastHashCheck.position == 2)
        assert(lastHashCheck.lastPosition == 2)
        let firstHashCheck = try await sdk1.checkSigchainHashAsync(
            withUserId: user1AccountInfo.userId,
            expectedHash: user1FirstSigchainHash.sigchainHash,
            position: -1)
        assert(firstHashCheck.found)
        assert(firstHashCheck.position == 0)
        assert(firstHashCheck.lastPosition == 2)
        let badPositionCheck = try await sdk2.checkSigchainHashAsync(
            withUserId: user1AccountInfo.userId,
            expectedHash: user1FirstSigchainHash.sigchainHash,
            position: 1)
        assert(badPositionCheck.found == false)
        // For badPositionCheck, position cannot be asserted as it is not set when the hash is not found.
        assert(badPositionCheck.lastPosition == 2)

        // Group TMR temporary key

        // First, create a group to test on. sdk1 create a TMR key to this group, sdk2 will join.
        let groupTMRName = "group-tmr"
        let groupTMRMembers = [user1AccountInfo.userId]
        let groupTMRAdmins = [user1AccountInfo.userId]
        let groupTMRId = try await sdk1.createGroupAsync(
            withGroupName: groupTMRName,
            members: groupTMRMembers,
            admins: groupTMRAdmins,
            privateKeys: nil)

        // WARNING: This should be a cryptographically random buffer of 64 bytes.
        // This random generation is NOT good enough.
        let gTMRRawOverEncryptionKey = randomData(length: 64)

        // We defined a two man rule recipient earlier. We will use it again.
        // The authentication factor is defined by `tmrAuthFactor`.
        // Also we already have the TMR JWT associated with it: `tmrJWT.token`

        let gTMRTKCreated = try await sdk1.createGroupTMRTemporaryKeyAsync(
            withGroupId: groupTMRId,
            authFactor: tmrAuthFactor,
            isAdmin: false,
            rawOverEncryptionKey: gTMRRawOverEncryptionKey)

        let gTMRList = try await sdk1.listGroupTMRTemporaryKeysAsync(withGroupId: groupTMRId, page: 1, all: false)
        assert(gTMRList.nbPage == 1)
        assert(gTMRList.keys.count == 1)
        assert(gTMRList.keys[0].groupId == groupTMRId)
        assert(gTMRList.keys[0].keyId == gTMRTKCreated.keyId)

        let gTMRSearch = try await sdk2.searchGroupTMRTemporaryKeysAsync(withTmrJWT: tmrJWT.token, options: nil)
        assert(gTMRSearch.nbPage == 1)
        assert(gTMRSearch.keys.count == 1)
        assert(gTMRSearch.keys[0].groupId == groupTMRId)
        assert(gTMRSearch.keys[0].keyId == gTMRTKCreated.keyId)

        try await sdk2.convertGroupTMRTemporaryKeyAsync(
            withGroupId: groupTMRId,
            temporaryKeyId: gTMRTKCreated.keyId,
            tmrJWT: tmrJWT.token,
            rawOverEncryptionKey: gTMRRawOverEncryptionKey,
            deleteOnConvert: false)
        try await sdk1.deleteGroupTMRTemporaryKeyAsync(
            withGroupId: groupTMRId,
            temporaryKeyId: gTMRTKCreated.keyId)

        // Heartbeat can be used to check if proxies and firewalls are configured
        // properly so that the app can reach Seald's servers.
        try await sdk1.heartbeatAsync()

        // close SDKs
        try await sdk1.closeAsync()
        try await sdk2.closeAsync()
        try await sdk3.closeAsync()

        print("SDK tests success!")
        return true
    } catch {
        print("SDK tests failed")
        print(error)
        return false
    }
}

func testSealdSsksPassword() async -> Bool {
    do {
        let rand = randomString(length: 10)
        let userId = "user-\(rand)"
        // Simulating a Seald identity with random data, for a simpler example.
        let userIdentity = randomData(length: 10) // should be the result of: sdk.exportIdentity()

        let ssksPassword = SealdSsksPasswordPlugin(ssksURL: testCredentials.ssksURL,
        appId: testCredentials.appId, instanceName: "SdkDemoAppIosSwift", logLevel: -1, logNoColor: true)

        // Test with password
        let userPassword = randomString(length: 10)

        // Saving the identity with a password
        let ssksId1 = try await ssksPassword.saveIdentityAsync(
            withUserId: userId,
            password: userPassword,
            identity: userIdentity
        )
        assert(ssksId1 != "")

        // Retrieving the identity with the password
        let retrieveResp = try await ssksPassword.retrieveIdentityAsync(withUserId: userId, password: userPassword)
        assert(retrieveResp == userIdentity)

        // Changing the password
        let newPassword = "another password"
        let ssksId1b = try await ssksPassword.changeIdentityPasswordAsync(
            withUserId: userId,
            currentPassword: userPassword,
            newPassword: newPassword)
        assert(ssksId1b != ssksId1)

        // The previous password does not work anymore
        do {
            try await ssksPassword.retrieveIdentityAsync(withUserId: userId, password: userPassword)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String == "SSKSPASSWORD_CANNOT_FIND_IDENTITY")
        }

        // Retrieving with the new password works
        let retrieveRespNewPassword = try await ssksPassword.retrieveIdentityAsync(
            withUserId: userId,
            password: newPassword)
        assert(retrieveRespNewPassword == userIdentity)

        // Test with raw keys
        let rawStorageKey = randomString(length: 32)
        let rawEncryptionKey = randomData(length: 64)

        // Saving identity with raw keys
        let ssksId2 = try await ssksPassword.saveIdentityAsync(
            withUserId: userId,
            rawStorageKey: rawStorageKey,
            rawEncryptionKey: rawEncryptionKey,
            identity: userIdentity)
        assert(ssksId2 != "")

        // Retrieving the identity with raw keys
        let retrieveRespRawKeys = try await ssksPassword.retrieveIdentityAsync(
            withUserId: userId,
            rawStorageKey: rawStorageKey,
            rawEncryptionKey: rawEncryptionKey)
        assert(retrieveRespRawKeys == userIdentity)

        // Deleting the identity by saving an empty `Data`
        let emptyData = Data.init()
        let ssksId2b = try await ssksPassword.saveIdentityAsync(
            withUserId: userId,
            rawStorageKey: rawStorageKey,
            rawEncryptionKey: rawEncryptionKey,
            identity: emptyData)
        assert(ssksId2b == ssksId2)

        // After deleting the identity, cannot retrieve anymore
        do {
            try await ssksPassword.retrieveIdentityAsync(
                withUserId: userId, rawStorageKey: rawStorageKey, rawEncryptionKey: rawEncryptionKey)
            assert(false, "expected error")
        } catch {
            assert((error as NSError).userInfo["code"] as! String == "SSKSPASSWORD_CANNOT_FIND_IDENTITY")
        }

        print("SSKS Password tests success!")
        return true
    } catch {
        print("SDK Password tests failed")
        print(error)
        return false
    }
}

func testSealdSsksTMR() async -> Bool {
    do {
        // rawTMRSymKey is a secret, generated and stored by your _backend_, unique for the user.
        // It can be retrieved by client-side when authenticated (usually as part of signup/sign-in call response).
        // This *MUST* be a cryptographically random buffer of 64 bytes.
        let rawTMRSymKey = randomData(length: 64)

        let SSKSBackend = SSKSBackend(
            keyStorageURL: testCredentials.ssksURL,
            appId: testCredentials.appId,
            appKey: testCredentials.ssksBackendAppKey)

        // First, we need to simulate a user. For a simpler example, we will use random data.
        // userId is the ID of the user in your app.
        let rand = randomString(length: 10)
        let userId = "user-\(rand)"
        // userIdentity is the user's exported identity that you want to store on SSKS
        let userIdentity = randomData(length: 10) // should be the result of: sdk.exportIdentity()

        let ssksTMR = SealdSsksTMRPlugin(ssksURL: testCredentials.ssksURL,
        appId: testCredentials.appId, instanceName: "SdkDemoAppIosSwift", logLevel: -1, logNoColor: true)

        // Define an AuthFactor: the user's email address.
        // AuthFactor can be an email `AuthFactorType.EM` or a phone number `AuthFactorType.SMS`
        let userEM = "user-\(rand)@test.com"
        let authFactor = SealdTmrAuthFactor(value: userEM, type: "EM")

        // The app backend creates an SSKS authentication session to save the identity.
        // This is the first time that this email is storing an identity, so `mustAuthenticate` is false.
        let authSessionSave = try await SSKSBackend.challengeSend(
            userId: userId,
            authFactor: authFactor,
            createUser: true,
            forceAuth: false,
            // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'.
            // In production, you cannot use this.
            fakeOtp: true
        )
        assert(authSessionSave.mustAuthenticate == false)

        // Saving the identity. No challenge necessary because `mustAuthenticate` is false.
        let saveIdentityRes1 = try await ssksTMR.saveIdentityAsync(
            authSessionSave.sessionId,
            authFactor: authFactor,
            rawTMRSymKey: rawTMRSymKey,
            identity: userIdentity
        )
        assert(saveIdentityRes1.ssksId != "")
        assert(saveIdentityRes1.authenticatedSessionId == nil)

        // The app backend creates another session to retrieve the identity.
        // The identity is already saved, so `mustAuthenticate` is true.
        let authSessionRetrieve = try await SSKSBackend.challengeSend(
            userId: userId,
            authFactor: authFactor,
            createUser: true,
            forceAuth: false,
            // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'.
            // In production, you cannot use this.
            fakeOtp: true
)
        assert(authSessionRetrieve.mustAuthenticate == true)

        // Retrieving identity. Challenge is necessary for this.
        // on this test server, the challenge is fixed. In an actual app, this will be the challenge recieved by the
        // user by email or SMS.
        let retrieveResp = try await ssksTMR.retrieveIdentityAsync(
            authSessionRetrieve.sessionId,
            authFactor: authFactor,
            rawTMRSymKey: rawTMRSymKey,
            challenge: testCredentials.ssksTMRChallenge
        )
        assert(retrieveResp.shouldRenewKey == true)
        assert(retrieveResp.identity == userIdentity)

        // If initial key has been saved without being fully authenticated, you should renew the user's private key,
        // and save it again.
        // sdk.renewKeys(Duration.ofDays(365 * 5))

        // Let's simulate the renew with another random identity
        let identitySecondKey =  randomData(length: 10) // should be the result of: sdk.exportIdentity()

        // to save the newly renewed identity on the server, you can use the `authenticatedSessionId` from the response
        // to `retrieveIdentityAsync`, with no challenge
        let saveIdentityRes2 = try await ssksTMR.saveIdentityAsync(
            retrieveResp.authenticatedSessionId,
            authFactor: authFactor,
            rawTMRSymKey: rawTMRSymKey,
            identity: identitySecondKey
        )
        assert(saveIdentityRes2.ssksId == saveIdentityRes1.ssksId)
        assert(saveIdentityRes2.authenticatedSessionId == nil)

        // And now let's retrieve this new saved identity
        let authSessionRetrieve2 = try await SSKSBackend.challengeSend(
            userId: userId,
            authFactor: authFactor,
            createUser: true,
            forceAuth: false,
            // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'.
            // In production, you cannot use this.
            fakeOtp: true
        )
        assert(authSessionRetrieve2.mustAuthenticate == true)
        let retrievedSecondKey = try await ssksTMR.retrieveIdentityAsync(
            authSessionRetrieve2.sessionId,
            authFactor: authFactor,
            rawTMRSymKey: rawTMRSymKey,
            challenge: testCredentials.ssksTMRChallenge
        )
        assert(retrievedSecondKey.shouldRenewKey == false) // The identity was saved with a challenge : no need to renew
        assert(retrievedSecondKey.identity == identitySecondKey)

        // Try retrieving with another SealdSsksTMRPlugin instance
        let ssksTMRInst2 = SealdSsksTMRPlugin(
            ssksURL: testCredentials.ssksURL,
            appId: testCredentials.appId,
            instanceName: "SdkDemoAppIosSwift",
            logLevel: -1,
            logNoColor: true)

        let authSessionRetrieve3 = try await SSKSBackend.challengeSend(
            userId: userId,
            authFactor: authFactor,
            createUser: true,
            forceAuth: true,
            // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'.
            // In production, you cannot use this.
            fakeOtp: true
        )
        assert(authSessionRetrieve3.mustAuthenticate == true)
        let inst2Retrieve = try await ssksTMRInst2.retrieveIdentityAsync(
            authSessionRetrieve3.sessionId,
            authFactor: authFactor,
            rawTMRSymKey: rawTMRSymKey,
            challenge: testCredentials.ssksTMRChallenge
        )
        assert(inst2Retrieve.shouldRenewKey == false)
        assert(inst2Retrieve.identity == identitySecondKey)

        print("SSKS TMR tests success!")
        return true
    } catch {
        print("SDK TMR tests failed")
        print(error)
        return false
    }
}

struct ContentView: View {
    @State private var statusSdk = "Running..."
    @State private var statusSsksPassword = "Running..."
    @State private var statusSsksTmr = "Running..."

    var body: some View {
        VStack {
            Text("test SDK: \(statusSdk)")
                .padding()
            Text("test SSKS Password: \(statusSsksPassword)")
                .padding()
            Text("test SSKS TMR: \(statusSsksTmr)")
                .padding()
        }
        .task {
                await runTests()
            }
    }

    func runTests() async {
        // Run tests
        let taskSdk = Task { [self] in
            let result = await testSealdSDK()
            statusSdk = result ? "success" : "error"
        }
        let taskSsksPassword = Task { [self] in
            let result = await testSealdSsksPassword()
            statusSsksPassword = result ? "success" : "error"
        }
        let taskSsksTmr = Task { [self] in
            let result = await testSealdSsksTMR()
            statusSsksTmr = result ? "success" : "error"
        }

        await taskSdk.value
        await taskSsksPassword.value
        await taskSsksTmr.value
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

// swiftlint:enable force_cast
